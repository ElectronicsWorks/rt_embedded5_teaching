\documentclass[12pt]{report}
\usepackage{caption}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{%
    pdfborder = {0 0 0}
}
\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\captionfont}{\small}

\author{Bernd Porr}
\title{Realtime embedded coding under Linux}

\begin{document}

\maketitle

\tableofcontents

\chapter{Writing C++ device driver classes}

\begin{figure}[!hbt]
\begin{center}
\mbox{\includegraphics[width=\textwidth]{signals-timings}}
\end{center}
\caption{Dataflow and timing in low level realtime coding
\label{timing}}
\end{figure}

\section{Introduction}
Fig.~\ref{timing} shows the basic dataflow and how event timing is
established. While it's obvious that data needs to flow from/to the
hardware it's even more important to guarantee its timing in realtime
applications. On the hardware-side the timing is guaranteed by event
signals, data-ready signals and also by the timing of a serial
interface. The Linux kernel translates this timing info into blocking
I/O on pseudo filesystems such as /dev or /sys which means that a read
operation blocks till data has arrived or an event has happened. Some
low level libraries such as pigpio translate them back into callbacks
but generally that needs to be done by you within a C++ class.

Ultimately, data transmission between the client and the C++ device
driver is achieved with \textsl{setters} and \textsl{callbacks}:
\begin{itemize}
\item C++ device driver class $\to$ client: \textbf{Callbacks}
\item Client $\to$ C++ device driver class: \textbf{Setters}
\end{itemize}

This chapter focuses on writing your own C++ device driver class
hiding away the complexity (and messy) low level C APIs and/or raw
device access to /dev and /sys. In order to get there we 1st need
to talk about the low level interfaces and then introduce callback
handlers to hand over data in a C++ framework.

\section{General recommendations how to write your C++ classes for devices}
As said above the main purpose of object oriented coding here is to
hide away the complexity of low level driver access and offer the
client a simple and safe way of connecting to the sensor. In
particular:
\begin{enumerate}
\item Setters and callbacks hand over \textsl{physical units}
  (temperature, acceleration, \ldots) and not raw integer values which
  have no meaning.
\item The sensor is configured by specifying physical units (time,
  voltage, temperature) and not sensor registers. Default config parameters
  should be specified that the class can be used straight away
  with little knowledge of the details.
\item The class handles the realtime processing by offering callback
  interfaces (i.e. based on classes with virtual and abstract methods)
  to transmit data from the sensor and methods to transmit data to the sensor.
\item The class is re-usable outwith of your specific project and has
  its own cmake project (for example in a subdirectory), i.e. is a
  library. It has doc-strings for all public functions and constants,
  has documentation generated by doxygen.
\item It has simple demo programs demonstrating how to use the class
  by a client.
\end{enumerate}

Keep S.O.L.I.D. \url{https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design}
in mind when writing your C++ device classes:
\begin{enumerate}
\item \textsl{Single responsibility}: If you have a temperature
sensor and an accelerometer then write two classes, one for the
temperature sensor and one of the accelerometer. In terms of
\item \textsl{Open-Closed principle} For example an ADC class
  has a callback which returns voltage to the client. However,
  you'll be connecting for example a temperature sensor to
  it so you'd like to be able to extend the class by for example
  overloading the callback methods so that you add the conversion
  from volt to degrees but not hacking the existing ADC class.
\item \textsl{Liskov substitution principle} Use abstract classes
  with abstract virtual functions, in particular for callback
  handlers.
\item \textsl{Interface Segregation Principle}:
  Keep functionality separate and rather divide it up in different
  classes. Imagine you have a universal IO class with SPI and I2C
  but your client really just needs SPI. Then the client is forced
  to deactivate I2C or in the worst case the class causes collateral
  damage without the client knowing why.
\end{enumerate}

\section{Low level userspace device access}
The following sections provide pointers of how to write
the C++ driver classes for different hardware protocols.

\subsection{SPI}
\begin{table}[!ht]
  \begin{center}
  \caption{SPI modes\label{spimodes}}
  \begin{tabular}{l|l|l|l}
    SPI Mode & 	CPOL & 	CPHA & Idle state \\
    \hline
    0& 	0&	0& 	L \\
    1& 	0&	1& 	L \\
    2& 	1&	1& 	H \\
    3& 	1&	0& 	H \\
  \end{tabular}
  \end{center}
\end{table}
SPI is a protocol which usually transmits and receives at the same
time. Even that data might not be used it needs to be matched up. So
for example sending 8 byes and recieving 8 bytes at the same time.

Transfer to/from SPI is best managed by the low level access to /dev.
Open the SPI device with the standard open() function:
\begin{verbatim}
int fd = open( "/dev/spidev0.0", O_RDWR);
\end{verbatim}

Then set the SPI mode (see table.~\ref{spimodes}):
\begin{verbatim}
int ret = ioctl(fd, SPI_IOC_WR_MODE, &mode);
\end{verbatim}
which is explained, for example, here:
\url{https://www.analog.com/en/analog-dialogue/articles/introduction-to-spi-interface.html}.

Since SPI transmits and receives at the same time we need to
use ioctl to do the communication.
Populate this struct:
\begin{verbatim}
struct spi_ioc_transfer tr = {
  .tx_buf = (unsigned long)tx1,
  .rx_buf = (unsigned long)rx1,
  .len = ARRAY_SIZE(tx1),
  .delay_usecs = delay,
  .speed_hz = speed,
  .bits_per_word = 8,
};
\end{verbatim}
which points to two character buffers ``tx'' and ``rx'' with the
same length.

Reading and simultaneous writing is happening then via the ioctrl
function:
\begin{verbatim}
int ret = ioctl(fd, SPI_IOC_MESSAGE(1), &tr);
\end{verbatim}

Sometimes the SPI protocol of a chip is so odd that even the raw
I/O via /dev won't work and you need to write your own bit banging
interface, for example done here for the ADC on the alphabot:
\url{https://github.com/berndporr/alphabot/blob/main/alphabot.cpp#L58}.
This is obviously far from ideal as it might require ``usleep'' commands
so that acquisition needs to be run in a separate thread (the alphabot
uses a timer callback in a separate thread).

Overall the SPI protocol is often device dependent and calls
for experimentation to get it to work. Often the SPI clock is also
the ADC conversion clock which requires a longer lasting clock signal
by transmitting dummy bytes in addition to the payload.

As a general recommendation do not use SAR converters which use the
SPI data clock also as acquisition clock as they are often not compatible
with the standard SPI transfers via /dev. Use sensors or ADCs which
have their own clock signal.


\subsection{I2C}
The I2C bus has two signal lines (SDA \& SDL) which must be pulled up
by resistors. Every I2C device has an address on the bus. You can scan
a bus with ``i2cdetect'' (part of the i2c-tools package):
\begin{verbatim}
root@raspberrypi:/home/pi# i2cdetect -y 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:                         -- -- -- -- -- -- -- -- 
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- 1e -- 
20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
50: -- -- -- -- -- -- -- -- 58 -- -- -- -- -- -- -- 
60: -- -- -- -- -- -- -- -- -- -- -- 6b -- -- -- -- 
70: -- -- -- -- -- -- -- --                         
root@raspberrypi:/home/pi# 
\end{verbatim}
In this case there are 3 I2C devices on the I2C bus at addresses
1E, 58 and 6B and need to be specified when
accessing the I2C device.

\subsubsection{Raw /dev/i2c access}
I2C either transmits or receives but never at the same time so here we
can use the standard C read/write commands. However, we need to use ioctrl to tell
the kernel the I2C address:
\begin{verbatim}
char buf[2];
int file = open("/dev/i2c-2",O_RDWR);
int addr = 0x58;
ioctl(file, I2C_SLAVE, addr);
write(file,buf,1)
read(file,buf,2)
\end{verbatim}
where ``addr'' is the I2C address. Then use standard read()
or write() commands. Usually the 1st write() operation tells the chip
which register to read or write to. Then write/read its register.

\subsubsection{I2C access via pigpio}
Access via pigpio (\url{http://abyz.me.uk/rpi/pigpio/cif.html})
is preferred in contrast to direct
access of the raw /dev/i2c because many different devices
can be connected to the I2C bus and pigpio manages this.
Simply install the development package:
\begin{verbatim}
sudo apt-get install libpigpio-dev
\end{verbatim}
which triggers then the install of the other relevant packages.
For example writing a byte to a register in an I2C sensor can be done with a
few commands:
\begin{verbatim}
int fd = i2cOpen(i2c_bus, address, 0);
i2cWriteByteData(fd, subAddress, data);
i2cClose(fd);
\end{verbatim}
where i2c\_bus is the I2C bus number (usually 1 on the RPI)
and the address is the I2C address of the device on that bus.
The subAddress here is the register address in the device.

\subsection{Access GPIO pins}
\subsubsection{/sys filesystem}
The GPIO of the raspberry PI can easily be controlled via
the /sys filesystem. This is slow but good for
debugging as you can directly write a
``0'' or ``1'' string to it and print the result. The
pseudo files are here:
\begin{verbatim}
/sys/class/gpio
\end{verbatim}
which contains files which directly relate to individual pins.
To be able to access a pin we need to tell Linux to make
it visible:
\begin{verbatim}
/sys/class/gpio/export
\end{verbatim}
For example, writing a 5 (in text form) to this file would
create the subdirectory \texttt{/sys/class/gpio/gpio5} for GPIO pin 5.

Then reading from
\begin{verbatim}
/sys/class/gpio/gpio5/value
\end{verbatim}
would give you the status of GPIO pin 5 and writing
to it would change it.
A thin wrapper around the GPIO sys filesystem is here: \url{https://github.com/berndporr/gpio-sysfs}.

\paragraph{GPIO interrupt handling via /sys}
The most important application for the /sys filesystem is to
do interrupt processing in userspace.
A thread can be put to sleep until an interrupt has happend on one of
the GPIO pins. This is done by monitoring the ``value''
of a GPIO pin in the /sys filesystem with the ``poll'' command:
\begin{verbatim}
struct pollfd fdset[1];
int nfds = 1;
int gpio_fd = open("/sys/class/gpio/gpio5/value", O_RDONLY | O_NONBLOCK );
memset((void*)fdset, 0, sizeof(fdset));
fdset[0].fd = gpio_fd;
fdset[0].events = POLLPRI;
int rc = poll(fdset, nfds, timeout);
if (fdset[0].revents & POLLPRI) {
   // dummy
   read(fdset[0].fd, buf, MAX_BUF);
}
\end{verbatim}
makes the thread go to sleep until an interrupt has occurred on
GPIO pin 5. Then the thread wakes up and execution continues.

\subsubsection{pigpio}
The above section has given you a deep understanding what's happening
under the hood on the sysfs-level but it's highly recommended to
use the pigpio library (\url{http://abyz.me.uk/rpi/pigpio/cif.html})
to read/write to GPIO pins or do interrupt programming.

For example to set GPIO pin 24 as an input just call:
\begin{verbatim}
gpioSetMode(24,PI_INPUT);
\end{verbatim}

To read from GPIO pin 24 just call:
\begin{verbatim}
int a = gpioRead(24)
\end{verbatim}

\paragraph{interrupt handling via pigpio}
pigpio manages GPIO interrupt handling by wrapping all the above
functionality into a single command where the client registers a
callback function which is called whenever a change has occurred on a
GPIO pin.
Specifically a method of the form:
\begin{verbatim}
class mySensorClass {
  ...
  static void gpioISR(int gpio, int level, uint32\_t tick, void* userdata)
  ...
}
\end{verbatim}
is registered with pigpio:
\begin{verbatim}
gpioSetISRFuncEx(24,RISING_EDGE,ISR_TIMEOUT,gpioISR,(void*)this);
\end{verbatim}
where ``this'' is the pointer to your class instance which is then used
to call a class method, here: ``dataReady()''.
\begin{verbatim}
class LSM9DS1 {
  void dataReady();
  static void gpioISR(int gpio, int level, uint32_t tick, void* userdata)
    {
        ((LSM9DS1*)userdata)->dataReady();
    }
};
\end{verbatim}
where here within the static function the void pointer is cast back into the instance pointer.
See \url{https://github.com/berndporr/LSM9DS1_RaspberryPi_CPP_Library} for the complete code.



\subsection{Access to hardware via special devices in /sys}
Some sensors are directly available via the sys filesystem in human readable format.

For example
\begin{verbatim}
cat /sys/class/thermal/thermal_zone0/temp
\end{verbatim}
gives you the temperature of the CPU.




\subsection{I2S: Audio}
The standard framework for audio is alsa: \url{https://github.com/alsa-project}.

ALSA works packet based where a read command
returns a chunk of audio or a chunk is written to.

First, the parameters are requested and the driver can modify or
reject them:
\begin{verbatim}
/* Signed 16-bit little-endian format */
  snd_pcm_hw_params_set_format(handle, params,
                               SND_PCM_FORMAT_S16_LE);

  /* One channel (mono) */
  snd_pcm_hw_params_set_channels(handle, params, 1);

  /* 44100 bits/second sampling rate (CD quality) */
  val = 44100;
  snd_pcm_hw_params_set_rate_near(handle, params,
                                  &val, &dir);
\end{verbatim}

Then playing sound is done in an endless loop were a read()
or write() command is issued. Both are blocking so that
it needs to run in a thread:

\begin{verbatim}
while(running) {
    rc = snd_pcm_writei(handle, buffer, frames);
    if (rc == -EPIPE) {
      /* EPIPE means underrun */
      fprintf(stderr, "underrun occurred\n");
      snd_pcm_prepare(handle);
    } else if (rc < 0) {
      fprintf(stderr,
              "error from writei: %s\n",
              snd_strerror(rc));
    }  else if (rc != (int)frames) {
      fprintf(stderr,
              "short write, write %d frames\n", rc);
    }
}
\end{verbatim}

For a full coding example ``aplay'' is a very
good start or ``arecord''. Both can be found here:
\url{https://github.com/alsa-project}.




\subsection{Accessing physical memory locations (danger!)}
In case you really need to access registers you can access
also memory directly. This should only be used as a last resort.
For example, setting the clock for the AD converter requires
turning a GPIO pin into a clock output pin. This is not yet
supported by the drivers so we need to program registers
on the RPI.
\begin{itemize}
\item Linux uses virtual addressed so that a pointer won't
point to a physical address. It points to three page
tables with an offset.
\item Special device /dev/mem which allows access of physical
memory.
\item The command ``mmap'' provides a pointer to a physical
address by opening /dev/mem.
\item Example:
\begin{verbatim}
int *addr;
if ((fd = open("/dev/mem", O_RDWR|O_SYNC)) < 0 ) {
    printf("Error opening file. \n");
    close(fd);
    return (-1);
}
addr = (int *)mmap(0, num*STRUCT_PAGE_SIZE, PROT_READ, MAP_PRIVATE,
            fd, 0x0000620000000000);
printf("addr: %p \n",addr);
printf("addr: %d \n",*addr);
\end{verbatim}
\item Use this with care! It's dangerous if not used properly.
\end{itemize}


\section{Kernel driver programming}
You can also create your own /dev/mydevice in the /dev filesystem
by writing a kernel driver and a matching userspace library. For
example the USB mouse has a driver in kernel space and translates
the raw data from the mouse into coordinates. However,
this is beyond the scope of this handout. If you want to embark
on this adventure then the best approach is to
find a kernel driver which does approximately what you want and then
modify it for your purposes.


\section{Callbacks in C++ device classes}
As said in the introduction your hardware device class has callback interfaces
to hand back the data to the client.

There are different ways of tackling the issue of callbacks but the
simplest one is defining a method as \textsl{abstract} and asking the
client to implement it in a derived class. That abstract function can
either be in a separate inteface class or part of the device class
itself. So, we have two options:
\begin{enumerate}
\item The callback is part of the device driver class:
\begin{verbatim}
class MyDriver {
          void start(DevSettings settings = DevSettings() );
          void stop();
          virtual void callback(float sample) = 0;
};
\end{verbatim}
\item The callback is port of an interface class:
\begin{verbatim}
class CallbackInterface {
          virtual void callback(float sample) = 0;
};
\end{verbatim}
and then registering it in the main device driver class:
\begin{verbatim}
class MyDriver {
          void registerCallback(CallbackInterface* cb);
};
\end{verbatim}
\end{enumerate}
These two options are now explained in greater detail.


\subsection{Creating a callback interface}
Here, we create a separate interface class containing a callback
as an abstract method:
\begin{verbatim}
class LSM9DS1callback {
public:
        virtual void hasSample(LSM9DS1Sample sample) = 0;
};
\end{verbatim}

The client then implements the abstract method ``hasSample()'', instantiates
the interface class and then saves its pointer in the device class, here called ``lsm9ds1Callback''.
\begin{verbatim}
void LSM9DS1::dataReady() {
        LSM9DS1Sample sample;
        // fills the sample struct with data
        // ...
        lsm9ds1Callback->hasSample(sample);
}
\end{verbatim}
The pointer to the interface instance is transmitted via a setter which
receives the pointer of the interface as an argument, for example:
\begin{verbatim}
        void registerCallback(LSM9DS1callback* cb);
\end{verbatim}
This allows to register a callback optionally. The client might not need
one or not always.
See
\url{https://github.com/berndporr/rpi_AD7705_daq}
for a complete example.

\subsection{Adding directly an abstract method to the device driver class}
Instead of creating a separate class containing the callback you
can also add the callback straight to the device driver class.
\begin{verbatim}
class ADS1115rpi {
        ...
        virtual void hasSample(float sample) = 0;
        ...
};
\end{verbatim}
This forces the client to implement the callback to be able to use
the class. This creates a very safe environment as all dependencies
are set at compile time and the abstract nature of the base class
makes clear what needs to be implemented.
See
\url{https://github.com/berndporr/rpi_ads1115} for a complete example.


\section{Conclusion}
\begin{figure}[!hbt]
\begin{center}
\mbox{\includegraphics[width=\textwidth]{gettersetters}}
\end{center}
\caption{A realtime system with two C++ classes. Communication
  between classes is achieved with callbacks (not getters) for incoming events
  and setters to send out control events. The control output itself
  receives its timing from the events so that the loop is traversed
  as quickly as possible.
\label{gettersetters}}
\end{figure}
From the sections above it's clear that Linux userspace low level
device access is complex, even without taking into account the
complexity of contemporary chips which have often a multitude of
registers and pages of documentation. Your task is to hide away
all this (scary) complexity in a C++ class and offer the client
an easy to understand interface.

Fig.~\ref{gettersetters} shows the overall communication between C++
classes.  The communication between C++ is done via callbacks
(\textsl{not} getters) and setters where the event from the sensor
  traverses according to the realtime requirements through the class
  via callbacks and then back to the control output via setters.  For
  example at a robot a collision sensor triggers a GPIO, this then
  triggers a callback to issue an avoidance action which in turn then
  sets the motors in reverse.


\end{document}
