<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2019.2 (Released June 5, 2019) -->
<HTML lang="EN">
<HEAD>
<TITLE>General recommendations how to write your C++ classes for devices</TITLE>
<META NAME="description" CONTENT="General recommendations how to write your C++ classes for devices">
<META NAME="keywords" CONTENT="realtime_embedded_coding">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2019.2">

<LINK REL="STYLESHEET" HREF="realtime_embedded_coding.css">

<LINK REL="next" HREF="node5.html">
<LINK REL="previous" HREF="node3.html">
<LINK REL="next" HREF="node5.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html76"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node5.html">Low level userspace device</A>
<B> Up:</B> <A
 HREF="node2.html">Writing C++ device driver</A>
<B> Previous:</B> <A
 HREF="node3.html">Introduction</A>
 &nbsp; <B>  <A ID="tex2html77"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->

<H1><A ID="SECTION00220000000000000000">
General recommendations how to write your C++ classes for devices</A>
</H1>
As said above the main purpose of object oriented coding here is to
hide away the complexity of low level driver access and offer the
client a simple and safe way of connecting to the sensor. In
particular:

<OL>
<LI>Getters, setters and callbacks hand over <SPAN  CLASS="textsl">physical units</SPAN>
  (temperature, acceleration, ...) and not raw integer values which
  have no meaning.
</LI>
<LI>The sensor is configured by specifying physical units (time,
  voltage, temperature) and not sensor registers. Default config parameters
  should be specified that the class can be used straight away
  with little knowledge of the details.
</LI>
<LI>The class handles the realtime processing by offering callback
  interfaces (i.e. based on classes with virtual and abstract methods)
  to transmit data from the sensor and methods to transmit data to the sensor.
</LI>
<LI>The class is re-usable outwith of your specific project and has
  its own cmake project (for example in a subdirectory), i.e. is a
  library. It has doc-strings for all public functions and constants,
  has documentation generated by doxygen.
</LI>
<LI>It has simple demo programs demonstrating how to use the class by a client.
</LI>
</OL>

<P>
Keep S.O.L.I.D. <kbd><A ID="tex2html2"
  HREF="https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design">https://www.digitalocean.com/community/conceptual_articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design</A></kbd>in mind when writing your C++ device classes:

<OL>
<LI><SPAN  CLASS="textsl">Single responsibility</SPAN>: If you have a temperature
sensor and an accelerometer then write two classes, one for the
temperature sensor and one of the accelerometer. In terms of
</LI>
<LI><SPAN  CLASS="textsl">Open-Closed principle</SPAN> For example an ADC class
  has a callback which returns voltage to the client. However,
  you'll be connecting for example a temperature sensor to
  it so you'd like to be able to extend the class by for example
  overloading the callback methods so that you add the conversion
  from volt to degrees but not hacking the existing ADC class.
</LI>
<LI><SPAN  CLASS="textsl">Interface Segregation Principle</SPAN>:
  Keep functionality separate and rather divide it up in different
  classes. Imagine you have a universal IO class with SPI and I2C
  but your client really just needs SPI. Then the client is forced
  to deactivate I2C or in the worst case the class causes collateral
  damage without the client knowing why.
</LI>
</OL>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node5.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node2.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node3.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html76"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node5.html">Low level userspace device</A>
<B> Up:</B> <A
 HREF="node2.html">Writing C++ device driver</A>
<B> Previous:</B> <A
 HREF="node3.html">Introduction</A>
 &nbsp; <B>  <A ID="tex2html77"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->
<ADDRESS>
<p><br /><a href="https://github.com/berndporr/rt_embedded5_teaching/">github / contact</a><br /></p>
</ADDRESS>
</BODY>
</HTML>
